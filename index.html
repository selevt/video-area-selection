<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Area Selection Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .drop-area {
            border: 3px dashed #ccc;
            border-radius: 5px;
            padding: 50px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .drop-area:hover, .drop-area.dragover {
            background-color: #f5f5f5;
        }
        
        .video-container {
            position: relative;
            margin-bottom: 20px;
            display: none; /* Hidden by default until video is loaded */
        }
        
        video {
            max-width: 100%;
            max-height: 70vh;
            display: block;
            margin: 0 auto; /* Center the video */
        }
        
        .video-wrapper {
            position: relative; /* Container for video and overlay */
            display: inline-block; /* Shrink to fit video size */
            margin: 0 auto;
            line-height: 0; /* Remove extra space below inline element */
        }
        
        .video-outer-container {
            text-align: center; /* Center the video wrapper */
        }
        
        .selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            cursor: crosshair;
            display: none; /* Hidden by default, shown when in selection mode */
            z-index: 10; /* Ensure overlay is above video but below handles */
            user-select: none; /* Prevent text selection while dragging */
        }
        
        .selecting {
            cursor: crosshair !important; /* Force crosshair cursor when selecting */
        }
        
        .selection-box {
            position: absolute;
            border: 2px solid red;
            background-color: rgba(255, 0, 0, 0.2);
            display: none;
            z-index: 20; /* Above overlay but below handles */
        }
        
        .selection-box.playback-mode {
            opacity: 0.4; /* Fade out in playback mode */
            pointer-events: none; /* Disable interaction in playback mode */
            border: 2px dashed red; /* Dashed border to indicate it's not interactive */
        }
        
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: white;
            border: 1px solid red;
            z-index: 30; /* Ensure handles are always on top */
        }
        
        .handle-nw { cursor: nw-resize; top: -5px; left: -5px; }
        .handle-ne { cursor: ne-resize; top: -5px; right: -5px; }
        .handle-sw { cursor: sw-resize; bottom: -5px; left: -5px; }
        .handle-se { cursor: se-resize; bottom: -5px; right: -5px; }
        
        .mode-controls {
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
        }
        
        .mode-toggle {
            display: inline-block;
            padding: 8px 16px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            margin: 0 5px;
        }
        
        .mode-toggle.active {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }
        
        .coordinates {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            display: none;
        }
        
        .compact-coords {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .coord-item {
            font-weight: bold;
        }
        
        .coord-item span {
            font-weight: normal;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        .file-input {
            display: none;
        }
        
        /* Template System Styles */
        .template-system {
            margin-top: 20px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
        
        .template-form {
            margin-bottom: 15px;
        }
        
        .form-row {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .template-input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            flex-grow: 1;
        }
        
        .template-btn {
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .template-btn:hover {
            background-color: #0056b3;
        }
        
        .cancel-btn {
            background-color: #6c757d;
        }
        
        .cancel-btn:hover {
            background-color: #5a6268;
        }
        
        .info-text {
            color: #666;
            margin-bottom: 15px;
        }
        
        .templates-list {
            border-top: 1px solid #eee;
            padding-top: 10px;
            margin-bottom: 15px;
        }
        
        .template-item {
            margin-bottom: 12px;
            padding: 8px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #eee;
        }
        
        .template-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .template-name {
            font-weight: bold;
        }
        
        .template-actions {
            display: flex;
            gap: 5px;
        }
        
        .template-edit {
            background-color: #ffc107;
            color: #212529;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .template-edit:hover {
            background-color: #e0a800;
        }
        
        .template-delete {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .template-delete:hover {
            background-color: #c82333;
        }
        
        .template-output-row {
            display: flex;
            margin-bottom: 5px;
            align-items: stretch;
        }
        
        .template-output {
            border: 1px solid #ddd;
            padding: 10px;
            background-color: white;
            border-radius: 3px 0 0 3px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            flex-grow: 1;
        }
        
        .copy-btn {
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 0 3px 3px 0;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
            margin-left: -1px; /* To avoid double border */
            white-space: nowrap;
            display: flex;
            align-items: center;
        }
        
        .copy-btn:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>
    <h1>Video Area Selection Tool</h1>
    
    <div class="drop-area" id="dropArea">
        <p>Drag & drop your video file here or click to select</p>
        <input type="file" id="fileInput" class="file-input" accept="video/*">
    </div>
    
    <div class="video-container" id="videoContainer">
        <div class="mode-controls">
            <div id="playbackMode" class="mode-toggle active">Video Playback Mode</div>
            <div id="selectionMode" class="mode-toggle">Selection Mode</div>
        </div>
        <div class="video-outer-container">
            <div class="video-wrapper">
                <video id="videoElement" controls></video>
                <div class="selection-overlay" id="selectionOverlay"></div>
                <div class="selection-box" id="selectionBox">
                    <div class="resize-handle handle-nw" id="handleNW"></div>
                    <div class="resize-handle handle-ne" id="handleNE"></div>
                    <div class="resize-handle handle-sw" id="handleSW"></div>
                    <div class="resize-handle handle-se" id="handleSE"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="coordinates" id="coordinates">
        <h3>Selection Coordinates</h3>
        <div class="compact-coords">
            <div class="coord-item">Position: <span id="originalPosition">-</span></div>
            <div class="coord-item">Size: <span id="originalWidth">-</span> Ã— <span id="originalHeight">-</span></div>
            <div class="coord-item">Video: <span id="videoResolution">-</span></div>
        </div>
        
        <div class="template-system">
            <div id="templatesList" class="templates-list">
                <!-- Templates will be added here dynamically -->
            </div>
            
            <div class="template-form">
                <div class="form-row">
                    <input type="text" id="templateName" placeholder="Template Name" class="template-input">
                    <input type="text" id="templateContent" placeholder="Template (use {left}, {top}, {width}, {height})" class="template-input">
                    <button id="saveTemplate" class="template-btn">Save Template</button>
                    <button id="cancelEditTemplate" class="template-btn cancel-btn" style="display: none;">Cancel</button>
                </div>
                <div class="info-text">
                    <small>Available variables: {left}, {top}, {width}, {height}</small>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const videoContainer = document.getElementById('videoContainer');
        const videoElement = document.getElementById('videoElement');
        const selectionOverlay = document.getElementById('selectionOverlay');
        const selectionBox = document.getElementById('selectionBox');
        const coordinatesDiv = document.getElementById('coordinates');
        
        // Mode toggle controls
        const playbackModeButton = document.getElementById('playbackMode');
        const selectionModeButton = document.getElementById('selectionMode');
        
        // Resize handles
        const handleNW = document.getElementById('handleNW');
        const handleNE = document.getElementById('handleNE');
        const handleSW = document.getElementById('handleSW');
        const handleSE = document.getElementById('handleSE');
        
        // Display elements
        const originalPosition = document.getElementById('originalPosition');
        const originalWidth = document.getElementById('originalWidth');
        const originalHeight = document.getElementById('originalHeight');
        const videoResolution = document.getElementById('videoResolution');
        
        // Template system elements
        const templateNameInput = document.getElementById('templateName');
        const templateContentInput = document.getElementById('templateContent');
        const saveTemplateBtn = document.getElementById('saveTemplate');
        const cancelEditBtn = document.getElementById('cancelEditTemplate');
        const templatesListDiv = document.getElementById('templatesList');
        
        // Variables for selection
        let isSelecting = false;
        let isResizing = false;
        let activeHandle = null;
        let startX, startY;
        let selectionLeft, selectionTop, selectionWidth, selectionHeight;
        let isSelectionMode = false; // Default is playback mode
        let originalVideoWidth, originalVideoHeight;
        let lastMoveEvent = null; // To track mousemove events
        
        // Load video when file is selected
        function handleFileSelection(file) {
            if (file && file.type.startsWith('video/')) {
                const videoURL = URL.createObjectURL(file);
                videoElement.src = videoURL;
                
                videoElement.onloadedmetadata = function() {
                    // Store original video dimensions
                    originalVideoWidth = videoElement.videoWidth;
                    originalVideoHeight = videoElement.videoHeight;
                    
                    // Display video resolution
                    videoResolution.textContent = `${originalVideoWidth} Ã— ${originalVideoHeight}`;
                    
                    // Show video container and coordinates section
                    videoContainer.style.display = 'block';
                    coordinatesDiv.style.display = 'block';
                    
                    // Set overlay to match video size
                    updateSelectionOverlaySize();
                };
                
                // Video loaded, show video and hide drop area
                dropArea.style.display = 'none';
            } else {
                alert('Please select a valid video file.');
            }
        }
        
        // Event listeners for drag and drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropArea.classList.add('dragover');
        }
        
        function unhighlight() {
            dropArea.classList.remove('dragover');
        }
        
        dropArea.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const file = dt.files[0];
            handleFileSelection(file);
        }
        
        // Click to select file
        dropArea.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                handleFileSelection(this.files[0]);
            }
        });
        
        // Mode toggle functionality
        playbackModeButton.addEventListener('click', function() {
            if (!isSelectionMode) return; // Already in playback mode
            
            // Switch to playback mode
            isSelectionMode = false;
            selectionOverlay.style.display = 'none';
            playbackModeButton.classList.add('active');
            selectionModeButton.classList.remove('active');
            videoElement.controls = true;
            
            // Make selection box non-interactive but still visible if it exists
            if (selectionBox.style.display === 'block') {
                selectionBox.classList.add('playback-mode');
            }
        });
        
        selectionModeButton.addEventListener('click', function() {
            if (isSelectionMode) return; // Already in selection mode
            
            // Switch to selection mode
            isSelectionMode = true;
            updateSelectionOverlaySize();
            selectionOverlay.style.display = 'block';
            selectionModeButton.classList.add('active');
            playbackModeButton.classList.remove('active');
            videoElement.controls = false; // Hide video controls in selection mode
            
            // Keep the selection box if it exists and make it fully interactive again
            if (selectionBox.style.display === 'block') {
                selectionBox.classList.remove('playback-mode');
            }
        });
        
        // Helper function to ensure overlay matches video size
        function updateSelectionOverlaySize() {
            // Since we're using a layout that automatically sizes the overlay
            // with the video, we don't need to manually set dimensions.
            // We no longer reset the selection box when the video size changes.
        }
        
        // Make sure overlay stays aligned with video when window resizes
        window.addEventListener('resize', updateSelectionOverlaySize);
        
        // Key controls for video navigation (work in both modes)
        document.addEventListener('keydown', function(e) {
            // Skip if the target is an input element or textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            if (videoElement.src) {
                if (e.code === 'Space') {
                    // Space bar for play/pause
                    e.preventDefault();
                    if (videoElement.paused) {
                        videoElement.play();
                    } else {
                        videoElement.pause();
                    }
                } else if (e.code === 'ArrowLeft') {
                    // Left arrow for step back
                    e.preventDefault();
                    videoElement.currentTime = Math.max(0, videoElement.currentTime - (e.shiftKey ? 1 : 0.04));
                } else if (e.code === 'ArrowRight') {
                    // Right arrow for step forward
                    e.preventDefault();
                    videoElement.currentTime = Math.min(videoElement.duration, videoElement.currentTime + (e.shiftKey ? 1 : 0.04));
                } else if (e.code === 'KeyM') {
                    // M key to toggle between modes
                    e.preventDefault();
                    if (isSelectionMode) {
                        playbackModeButton.click();
                    } else {
                        selectionModeButton.click();
                    }
                }
            }
        });
        
        // Selection box functionality
        selectionOverlay.addEventListener('mousedown', function(e) {
            e.preventDefault(); // Prevent video play/pause
            
            if (videoElement.src && isSelectionMode) {
                const rect = videoElement.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Constrain to video boundaries
                if (mouseX < 0 || mouseX > rect.width || mouseY < 0 || mouseY > rect.height) {
                    return; // Clicked outside actual video area
                }
                
                // Check if we're clicking inside an existing selection
                const selBoxLeft = parseInt(selectionBox.style.left) || 0;
                const selBoxTop = parseInt(selectionBox.style.top) || 0;
                const selBoxWidth = parseInt(selectionBox.style.width) || 0;
                const selBoxHeight = parseInt(selectionBox.style.height) || 0;
                
                const insideExistingSelection = 
                    selectionBox.style.display === 'block' &&
                    mouseX >= selBoxLeft && 
                    mouseX <= selBoxLeft + selBoxWidth && 
                    mouseY >= selBoxTop && 
                    mouseY <= selBoxTop + selBoxHeight;
                
                if (!insideExistingSelection) {
                    // Start new selection
                    isSelecting = true;
                    
                    // Store initial mouse position
                    startX = mouseX;
                    startY = mouseY;
                    
                    // Start showing the selection box right away with minimal dimensions
                    selectionBox.style.left = startX + 'px';
                    selectionBox.style.top = startY + 'px';
                    selectionBox.style.width = '1px';
                    selectionBox.style.height = '1px';
                    selectionBox.style.display = 'block';
                    
                    // Track the current values
                    selectionLeft = startX;
                    selectionTop = startY;
                    selectionWidth = 1;
                    selectionHeight = 1;
                    
                    updateCoordinates(startX, startY, 1, 1);
                    
                    // Critical fix: Listen for mousemove on document during selection
                    // to catch events that might be missed by the overlay
                    document.addEventListener('mousemove', documentMouseMoveHandler);
                }
            }
        });
        
        selectionOverlay.addEventListener('mousemove', function(e) {
            if (isSelecting && videoElement.src && isSelectionMode) {
                e.preventDefault();
                
                const rect = videoElement.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                // Constrain to video boundaries
                const videoRect = videoElement.getBoundingClientRect();
                const constrainedX = Math.min(Math.max(0, currentX), videoRect.width);
                const constrainedY = Math.min(Math.max(0, currentY), videoRect.height);
                
                // Calculate dimensions and position of selection box
                const width = Math.max(1, Math.abs(constrainedX - startX));
                const height = Math.max(1, Math.abs(constrainedY - startY));
                const left = Math.min(startX, constrainedX);
                const top = Math.min(startY, constrainedY);
                
                // Update selection box styling - already visible from mousedown
                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = width + 'px';
                selectionBox.style.height = height + 'px';
                
                // Store this event to reuse in case we need it on mouseup
                lastMoveEvent = {
                    clientX: e.clientX,
                    clientY: e.clientY
                };
                
                selectionLeft = left;
                selectionTop = top;
                selectionWidth = width;
                selectionHeight = height;
                
                updateCoordinates(left, top, width, height);
            }
            // We no longer handle resizing in the overlay mousemove handler
            // It's now handled by the documentResizeHandler
        });
        
        selectionOverlay.addEventListener('mouseup', function(e) {
            e.preventDefault();
            
            if (isSelecting) {
                // Remove document mousemove handler
                document.removeEventListener('mousemove', documentMouseMoveHandler);
                
                // Process the last move event if it exists
                // This ensures we capture the final position
                if (lastMoveEvent) {
                    const event = new MouseEvent('mousemove', lastMoveEvent);
                    selectionOverlay.dispatchEvent(event);
                }
                
                isSelecting = false;
            }
        });
        
        selectionOverlay.addEventListener('mouseleave', function(e) {
            if (isSelecting) {
                e.preventDefault();
                // We will continue tracking via document events, not ending selection here
            }
        });
        
        // Resize handle events
        [handleNW, handleNE, handleSW, handleSE].forEach(handle => {
            handle.addEventListener('mousedown', function(e) {
                if (!isSelectionMode) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                isResizing = true;
                activeHandle = handle;
                
                // Store current selection dimensions
                selectionLeft = parseInt(selectionBox.style.left) || 0;
                selectionTop = parseInt(selectionBox.style.top) || 0;
                selectionWidth = parseInt(selectionBox.style.width) || 0;
                selectionHeight = parseInt(selectionBox.style.height) || 0;
                
                // Add document-level mousemove handler for resizing
                document.addEventListener('mousemove', documentResizeHandler);
            });
        });
        
        // Handler for document mousemove to catch events during selection
        function documentMouseMoveHandler(e) {
            if (isSelecting && videoElement.src && isSelectionMode) {
                const rect = videoElement.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                // Constrain to video boundaries
                const constrainedX = Math.min(Math.max(0, currentX), rect.width);
                const constrainedY = Math.min(Math.max(0, currentY), rect.height);
                
                // Calculate dimensions and position of selection box
                const width = Math.max(1, Math.abs(constrainedX - startX));
                const height = Math.max(1, Math.abs(constrainedY - startY));
                const left = Math.min(startX, constrainedX);
                const top = Math.min(startY, constrainedY);
                
                // Update selection box styling
                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = width + 'px';
                selectionBox.style.height = height + 'px';
                
                // Store the values
                selectionLeft = left;
                selectionTop = top;
                selectionWidth = width;
                selectionHeight = height;
                
                // Store this event for mouseup
                lastMoveEvent = {
                    clientX: e.clientX,
                    clientY: e.clientY
                };
                
                updateCoordinates(left, top, width, height);
            }
        }
        
        // Handler for document mousemove during resize operations
        function documentResizeHandler(e) {
            if (isResizing && videoElement.src && isSelectionMode) {
                e.preventDefault();
                
                const rect = videoElement.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                // Constrain to video boundaries
                const constrainedX = Math.min(Math.max(0, currentX), rect.width);
                const constrainedY = Math.min(Math.max(0, currentY), rect.height);
                
                let newLeft = selectionLeft;
                let newTop = selectionTop;
                let newWidth = selectionWidth;
                let newHeight = selectionHeight;
                
                // Handle resizing based on which handle is active
                switch (activeHandle) {
                    case handleNW:
                        // For NW handle, the bottom-right corner is fixed
                        // and we adjust top-left position and dimensions
                        newWidth = selectionLeft + selectionWidth - constrainedX;
                        newHeight = selectionTop + selectionHeight - constrainedY;
                        newLeft = constrainedX;
                        newTop = constrainedY;
                        break;
                    case handleNE:
                        // For NE handle, the bottom-left corner is fixed
                        // We adjust width and top position
                        newWidth = constrainedX - selectionLeft;
                        newHeight = selectionTop + selectionHeight - constrainedY;
                        newTop = constrainedY;
                        break;
                    case handleSW:
                        // For SW handle, the top-right corner is fixed
                        // We adjust width and left position
                        newWidth = selectionLeft + selectionWidth - constrainedX;
                        newHeight = constrainedY - selectionTop;
                        newLeft = constrainedX;
                        break;
                    case handleSE:
                        // For SE handle, the top-left corner is fixed
                        // We just adjust width and height
                        newWidth = constrainedX - selectionLeft;
                        newHeight = constrainedY - selectionTop;
                        break;
                }
                
                // Ensure minimum size of 1px
                if (newWidth < 1) {
                    newWidth = 1;
                    if (activeHandle === handleNW || activeHandle === handleSW) {
                        newLeft = selectionLeft + selectionWidth - 1;
                    }
                }
                
                if (newHeight < 1) {
                    newHeight = 1;
                    if (activeHandle === handleNW || activeHandle === handleNE) {
                        newTop = selectionTop + selectionHeight - 1;
                    }
                }
                
                // Update selection box styling
                selectionBox.style.left = newLeft + 'px';
                selectionBox.style.top = newTop + 'px';
                selectionBox.style.width = newWidth + 'px';
                selectionBox.style.height = newHeight + 'px';
                
                // Store the values
                selectionLeft = newLeft;
                selectionTop = newTop;
                selectionWidth = newWidth;
                selectionHeight = newHeight;
                
                updateCoordinates(newLeft, newTop, newWidth, newHeight);
            }
        }
        
        document.addEventListener('mouseup', function(e) {
            // Handle resizing end
            if (isResizing) {
                document.removeEventListener('mousemove', documentResizeHandler);
                isResizing = false;
                activeHandle = null;
            }
            
            // Handle selection end if mouse released outside overlay
            if (isSelecting) {
                isSelecting = false;
                
                // Remove document mousemove handler
                document.removeEventListener('mousemove', documentMouseMoveHandler);
                
                // Try to process the final position by simulating a mousemove on the overlay
                if (lastMoveEvent) {
                    const event = new MouseEvent('mousemove', {
                        clientX: lastMoveEvent.clientX,
                        clientY: lastMoveEvent.clientY
                    });
                    selectionOverlay.dispatchEvent(event);
                }
            }
        });
        
        // Template system variables and functions
        let templates = [];
        let currentSelectionValues = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        };
        
        // Load saved templates on page load
        function loadTemplates() {
            const savedTemplates = localStorage.getItem('videoSelectionTemplates');
            if (savedTemplates) {
                templates = JSON.parse(savedTemplates);
                renderTemplates();
            }
        }
        
        // Save templates to local storage
        function saveTemplates() {
            localStorage.setItem('videoSelectionTemplates', JSON.stringify(templates));
        }
        
        // Render all templates in the list
        function renderTemplates() {
            templatesListDiv.innerHTML = '';
            
            if (templates.length === 0) {
                templatesListDiv.innerHTML = '<p>No templates yet. Create one below!</p>';
                return;
            }
            
            templates.forEach((template, index) => {
                const templateOutput = applyTemplate(template.content);
                
                const templateItem = document.createElement('div');
                templateItem.className = 'template-item';
                templateItem.innerHTML = `
                    <div class="template-header">
                        <span class="template-name">${template.name}</span>
                        <div class="template-actions">
                            <button class="template-edit" data-index="${index}">Edit</button>
                            <button class="template-delete" data-index="${index}">Delete</button>
                        </div>
                    </div>
                    <div class="template-output-row">
                        <div class="template-output">${templateOutput}</div>
                        <button class="copy-btn" data-output="${encodeURIComponent(templateOutput)}">Copy</button>
                    </div>
                `;
                
                templatesListDiv.appendChild(templateItem);
            });
            
            // Add event listeners for delete buttons
            document.querySelectorAll('.template-delete').forEach(button => {
                button.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    templates.splice(index, 1);
                    saveTemplates();
                    renderTemplates();
                });
            });
            
            // Add event listeners for edit buttons
            document.querySelectorAll('.template-edit').forEach(button => {
                button.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    const template = templates[index];
                    
                    // Populate form with template data
                    templateNameInput.value = template.name;
                    templateContentInput.value = template.content;
                    
                    // Change save button to update button
                    saveTemplateBtn.textContent = 'Update Template';
                    saveTemplateBtn.dataset.editIndex = index;
                    
                    // Show cancel button
                    cancelEditBtn.style.display = 'inline-block';
                    
                    // Scroll to the form
                    templateNameInput.scrollIntoView({ behavior: 'smooth' });
                    templateNameInput.focus();
                });
            });
            
            // Add event listeners for copy buttons
            document.querySelectorAll('.copy-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const output = decodeURIComponent(this.getAttribute('data-output'));
                    copyToClipboard(output);
                });
            });
        }
        
        // Apply template with current selection values
        function applyTemplate(templateContent) {
            return templateContent
                .replace(/\{left\}/g, currentSelectionValues.left)
                .replace(/\{top\}/g, currentSelectionValues.top)
                .replace(/\{width\}/g, currentSelectionValues.width)
                .replace(/\{height\}/g, currentSelectionValues.height);
        }
        
        // Copy text to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(
                function() {
                    // Success feedback
                    const originalText = event.target.textContent;
                    event.target.textContent = "Copied!";
                    setTimeout(() => {
                        event.target.textContent = originalText;
                    }, 1000);
                },
                function() {
                    alert("Failed to copy to clipboard");
                }
            );
        }
        
        // Cancel edit button handler
        cancelEditBtn.addEventListener('click', function() {
            // Clear form
            templateNameInput.value = '';
            templateContentInput.value = '';
            
            // Reset save button
            saveTemplateBtn.textContent = 'Save Template';
            delete saveTemplateBtn.dataset.editIndex;
            
            // Hide cancel button
            cancelEditBtn.style.display = 'none';
        });
        
        // Save/Update template button handler
        saveTemplateBtn.addEventListener('click', function() {
            const name = templateNameInput.value.trim();
            const content = templateContentInput.value.trim();
            
            if (!name) {
                alert("Please provide a template name");
                return;
            }
            
            if (!content) {
                alert("Please provide template content");
                return;
            }
            
            // Check if we're editing an existing template
            const editIndex = this.dataset.editIndex;
            
            if (editIndex !== undefined) {
                // Update existing template
                templates[editIndex] = {
                    name: name,
                    content: content
                };
                // Remove edit index from button
                delete this.dataset.editIndex;
                // Restore button text
                this.textContent = 'Save Template';
                // Hide cancel button
                cancelEditBtn.style.display = 'none';
            } else {
                // Add new template
                templates.push({
                    name: name,
                    content: content
                });
            }
            
            saveTemplates();
            renderTemplates();
            
            // Clear inputs
            templateNameInput.value = '';
            templateContentInput.value = '';
        });
        
        // Initialize templates on page load
        loadTemplates();
        
        function updateCoordinates(x, y, width, height) {
            // Convert to original video dimensions
            if (videoElement.src && originalVideoWidth && originalVideoHeight) {
                // Calculate scale factors based on the actual displayed video size
                const videoDisplayWidth = videoElement.clientWidth;
                const videoDisplayHeight = videoElement.clientHeight;
                
                // Ensure we're not dividing by zero
                if (videoDisplayWidth > 0 && videoDisplayHeight > 0) {
                    const scaleX = originalVideoWidth / videoDisplayWidth;
                    const scaleY = originalVideoHeight / videoDisplayHeight;
                    
                    // Constrain selection to video dimensions
                    const constrainedX = Math.min(Math.max(0, x), videoDisplayWidth);
                    const constrainedY = Math.min(Math.max(0, y), videoDisplayHeight);
                    
                    // Constrain selection width/height
                    const constrainedWidth = Math.min(width, videoDisplayWidth - constrainedX);
                    const constrainedHeight = Math.min(height, videoDisplayHeight - constrainedY);
                    
                    // Calculate original coordinates
                    const originalX = Math.round(constrainedX * scaleX);
                    const originalY = Math.round(constrainedY * scaleY);
                    const originalW = Math.round(constrainedWidth * scaleX);
                    const originalH = Math.round(constrainedHeight * scaleY);
                    
                    // Update display
                    originalPosition.textContent = `(${originalX}, ${originalY})`;
                    originalWidth.textContent = `${originalW}`;
                    originalHeight.textContent = `${originalH}`;
                    
                    // Update current selection values for templates
                    currentSelectionValues = {
                        left: originalX,
                        top: originalY,
                        width: originalW,
                        height: originalH
                    };
                    
                    // Update all template outputs with new values
                    renderTemplates();
                }
            }
        }
    </script>
</body>
</html>
